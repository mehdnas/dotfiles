
#+title: My Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./.emacs.d/init.el :mkdirp yes
#+PROPERTY: header-args:yaml :tangle ./ansible/emacs_required_packages.yml :mkdirp yes

* Package System Setup

#+begin_src emacs-lisp

   ;; Initialize package sources
   (require 'package)

   (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                            ("org" . "https://orgmode.org/elpa/")
                            ("elpa" . "https://elpa.gnu.org/packages/")))

   (package-initialize)
   (unless package-archive-contents
     (package-refresh-contents))

     ;; Initialize use-package on non-Linux platforms
   (unless (package-installed-p 'use-package)
     (package-install 'use-package))

   (require 'use-package)
   (setq use-package-always-ensure t)

#+end_src

Vars file for required packages to be installed by ansible

#+begin_src yaml
  ---
  - emacs_required_packages:
#+end_src

* UI

** Appearance

*** Basic configuration

#+begin_src emacs-lisp

  (setq inhibit-startup-message t)

  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)            ; Disable the menu bar

  ;; Set up the visible bell
  (setq visible-bell t)

  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))

#+end_src

*** Color Theme
#+begin_src emacs-lisp

  (use-package doom-themes
    :init
    (load-theme 'doom-palenight t)
    (doom-themes-visual-bell-config))

#+end_src

*** Modeline

#+begin_src emacs-lisp

  (use-package all-the-icons)

  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 15)))

#+end_src

*** Frame transparency
#+begin_src emacs-lisp

  (set-frame-parameter (selected-frame) 'alpha '(90 . 90))
  (add-to-list 'default-frame-alist '(alpha . (90 . 90)))

#+end_src


** Improve scrolling

#+begin_src emacs-lisp

  (setq mouse-wheel-scroll-amount '(2 ((shift) . 1)))
  (setq mouse-wheel-progressive-speed nil)

#+end_src

** Ivy and Counsel

#+begin_src emacs-lisp

  (use-package ivy
    :diminish
    :bind (("C-s" . swiper)
           :map ivy-minibuffer-map
           ("TAB" . ivy-alt-done)
           ("C-l" . ivy-alt-done)
           ("C-j" . ivy-next-line)
           ("C-k" . ivy-previous-line)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-previous-line)
           ("C-l" . ivy-done)
           ("C-d" . ivy-switch-buffer-kill)
           :map ivy-reverse-i-search-map
           ("C-k" . ivy-previous-line)
           ("C-d" . ivy-reverse-i-search-kill))
    :config
    (ivy-mode 1))

  (use-package counsel
    :bind (("C-M-j" . 'counsel-switch-buffer)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history))
    :custom
    (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
    :config
    (counsel-mode 1))

  (use-package ivy-rich
    :after ivy counsel
    :init
    (ivy-rich-mode 1))

#+end_src

** Candidate sorting

#+begin_src emacs-lisp

  (use-package ivy-prescient
    :after counsel
    :custom
    (ivy-prescient-enable-filtering nil)
    :config
    ;; Uncomment the following line to have sorting remembered across sessions!
    ;(prescient-persist-mode 1)
    (ivy-prescient-mode 1))

#+end_src

** Helpful

#+begin_src emacs-lisp

  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-command helpful-key)
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))

#+end_src


* Key Bindings

** evil
#+begin_src emacs-lisp

  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

#+end_src

** Which Key

#+begin_src emacs-lisp

  (use-package which-key
    :diminish which-key-mode
    :config
    (which-key-mode)
    (setq which-key-idle-delay 0.5))

#+end_src

* Window management

** Logout

#+begin_src emacs-lisp

  (defun desktop-logout ()
    (interactive)
    (recentf-save-list)
    (save-some-buffers)
    (start-process-shell-command "logout" nil "lxsession-logout"))

#+end_src

** EXWM

#+begin_src emacs-lisp

  (use-package exwm
    :config
    ;; These keys should always pass through to Emacs
    (setq exwm-input-prefix-keys
      '(?\C-x
        ?\C-u
        ?\C-h
        ?\M-x
        ?\M-`
        ?\M-&
        ?\M-:
        ?\C-\M-j  ;; Buffer list
        ?\C-\ ))  ;; Ctrl+Space

    ;; Ctrl+Q will enable the next key to be sent directly
    (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)
    ;;(define-key exwm-mode-map [?s-Q] 'desktop-logout)

    ;; Set up global key bindings.  These always work, no matter the input state!
    ;; Keep in mind that changing this list after EXWM initializes has no effect.
    (setq exwm-input-global-keys
          `(
            ;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
            ([?\s-r] . exwm-reset)

            ;; Move between windows
            ([s-left] . windmove-left)
            ([s-right] . windmove-right)
            ([s-up] . windmove-up)
            ([s-down] . windmove-down)

            ;; Launch applications via shell command
            ([?\s-&] . (lambda (command)
                         (interactive (list (read-shell-command "$ ")))
                         (start-process-shell-command command nil command)))

            ;; Switch workspace
            ([?\s-w] . exwm-workspace-switch)
            ([?\s-'] . (lambda () (interactive) (exwm-workspace-switch-create 0)))

            ;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
            ,@(mapcar (lambda (i)
                        `(,(kbd (format "s-%d" i)) .
                          (lambda ()
                            (interactive)
                            (exwm-workspace-switch-create ,i))))
                      (number-sequence 0 9))))

    (exwm-input-set-key (kbd "s-SPC") 'counsel-linux-app)

    (exwm-enable))

#+end_src

* Terminal

#+begin_src emacs-lisp

  (use-package vterm
    :commands vterm
    :config
    (setq term-prompt-regexp "^\[[^$]*\]$ *")
    (setq vterm-max-scrollback 10000))

#+end_src

#+begin_src yaml
  # Packages required by vterm
    - cmake
    - libtool
    - gcc
#+end_src

* Editing configurations

** Auto-Revert changed files

#+begin_src emacs-lisp

  (setq global-auto-revert-none-file-buffers t)

  (global-auto-revert-mode 1)

#+end_src

** Match and Highlight matching Braces

#+begin_src emacs-lisp

  (use-package paren
    :config
    (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
    (show-paren-mode 1))

  (use-package smartparens
    :hook (prog-mode . smartparens-mode))

#+end_src

** Tab Settings

#+begin_src emacs-lisp

  (setq-default tab-width 3)
  (setq-default evil-shift-width tab-width)

  (setq-default indent-tabs-mode nil)

#+end_src

** Comenting lines

#+begin_src emacs-lisp

  (use-package evil-nerd-commenter
    :bind ("M-," . evilnc-comment-or-uncomment-lines))

#+end_src

** Automatically clean whitespace

#+begin_src emacs-lisp

  (use-package ws-butler
    :hook ((text-mode . ws-butler-mode)
           (prog-mode . ws-butler-mode)))

#+end_src

** Folding (origami)

#+begin_src emacs-lisp

  (use-package origami
    :hook (yaml-mode . origami-mode))

#+end_src
